{"id":"js/shader/fragmentSimulation.glsl","dependencies":[{"name":"/Users/benjamin/htdocs/face/package.json","includedInParent":true,"mtime":1628488138071}],"generated":{"js":"module.exports = \"#define GLSLIFY 1\\nuniform float time;\\nuniform float delta;\\nuniform sampler2D texturePosition;\\n\\n//\\n// Description : Array and textureless GLSL 2D simplex noise function.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : ijm\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//\\n\\nvec3 mod289(vec3 x) {\\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec2 mod289(vec2 x) {\\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec3 permute(vec3 x) {\\n    return mod289(((x*34.0)+1.0)*x);\\n}\\n\\nfloat noise(vec2 v)\\n{\\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\\n                      0.024390243902439); // 1.0 / 41.0\\n    // First corner\\n    vec2 i  = floor(v + dot(v, C.yy) );\\n    vec2 x0 = v -   i + dot(i, C.xx);\\n\\n    // Other corners\\n    vec2 i1;\\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\\n    //i1.y = 1.0 - i1.x;\\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\\n    // x1 = x0 - i1 + 1.0 * C.xx ;\\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\\n    vec4 x12 = x0.xyxy + C.xxzz;\\n    x12.xy -= i1;\\n\\n    // Permutations\\n    i = mod289(i); // Avoid truncation effects in permutation\\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\\n        + i.x + vec3(0.0, i1.x, 1.0 ));\\n\\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\\n    m = m*m ;\\n    m = m*m ;\\n\\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\\n\\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\\n    vec3 h = abs(x) - 0.5;\\n    vec3 ox = floor(x + 0.5);\\n    vec3 a0 = x - ox;\\n\\n    // Normalise gradients implicitly by scaling m\\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\\n\\n    // Compute final noise value at P\\n    vec3 g;\\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\\n    return 130.0 * dot(m, g);\\n}\\n\\nvec3 curl(float\\tx,\\tfloat\\ty,\\tfloat\\tz)\\n{\\n\\n    float\\teps\\t= 1., eps2 = 2. * eps;\\n    float\\tn1,\\tn2,\\ta,\\tb;\\n\\n    x += time * .05;\\n    y += time * .05; \\n    z += time * .05;\\n\\n    vec3\\tcurl = vec3(0.);\\n\\n    n1\\t=\\tnoise(vec2( x,\\ty\\t+\\teps ));\\n    n2\\t=\\tnoise(vec2( x,\\ty\\t-\\teps ));\\n    a\\t=\\t(n1\\t-\\tn2)/eps2;\\n\\n    n1\\t=\\tnoise(vec2( x,\\tz\\t+\\teps));\\n    n2\\t=\\tnoise(vec2( x,\\tz\\t-\\teps));\\n    b\\t=\\t(n1\\t-\\tn2)/eps2;\\n\\n    curl.x\\t=\\ta\\t-\\tb;\\n\\n    n1\\t=\\tnoise(vec2( y,\\tz\\t+\\teps));\\n    n2\\t=\\tnoise(vec2( y,\\tz\\t-\\teps));\\n    a\\t=\\t(n1\\t-\\tn2)/eps2;\\n\\n    n1\\t=\\tnoise(vec2( x\\t+\\teps,\\tz));\\n    n2\\t=\\tnoise(vec2( x\\t+\\teps,\\tz));\\n    b\\t=\\t(n1\\t-\\tn2)/eps2;\\n\\n    curl.y\\t=\\ta\\t-\\tb;\\n\\n    n1\\t=\\tnoise(vec2( x\\t+\\teps,\\ty));\\n    n2\\t=\\tnoise(vec2( x\\t-\\teps,\\ty));\\n    a\\t=\\t(n1\\t-\\tn2)/eps2;\\n\\n    n1\\t=\\tnoise(vec2(  y\\t+\\teps,\\tz));\\n    n2\\t=\\tnoise(vec2(  y\\t-\\teps,\\tz));\\n    b\\t=\\t(n1\\t-\\tn2)/eps2;\\n\\n    curl.z\\t=\\ta\\t-\\tb;\\n\\n    return\\tcurl;\\n}\\n\\nvoid main() {\\n\\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\\n    vec4 tmpPos = texture2D(texturePosition, uv);\\n    vec3 pos = tmpPos.xyz;\\n    float f = 1.;\\n    float amplitude = 0.0001;\\n    vec3 target = pos + amplitude * curl(f*pos.x, f*pos.y, f*pos.z); \\n\\n    gl_FragColor = vec4(target, 1.);\\n\\n}\\n\";"},"sourceMaps":{"js":{"mappings":[{"name":"module","generated":{"line":1,"column":0},"source":"js/shader/fragmentSimulation.glsl","original":{"line":1,"column":0}},{"generated":{"line":1,"column":6},"source":"js/shader/fragmentSimulation.glsl","original":{"line":1,"column":6}},{"name":"exports","generated":{"line":1,"column":7},"source":"js/shader/fragmentSimulation.glsl","original":{"line":1,"column":7}},{"generated":{"line":1,"column":14},"source":"js/shader/fragmentSimulation.glsl","original":{"line":1,"column":0}},{"generated":{"line":1,"column":17},"source":"js/shader/fragmentSimulation.glsl","original":{"line":1,"column":15}},{"generated":{"line":1,"column":3703},"source":"js/shader/fragmentSimulation.glsl","original":{"line":1,"column":0}}],"sources":{"js/shader/fragmentSimulation.glsl":"module.exports=\"#define GLSLIFY 1\\nuniform float time;\\nuniform float delta;\\nuniform sampler2D texturePosition;\\n\\n//\\n// Description : Array and textureless GLSL 2D simplex noise function.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : ijm\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//\\n\\nvec3 mod289(vec3 x) {\\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec2 mod289(vec2 x) {\\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec3 permute(vec3 x) {\\n    return mod289(((x*34.0)+1.0)*x);\\n}\\n\\nfloat noise(vec2 v)\\n{\\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\\n                      0.024390243902439); // 1.0 / 41.0\\n    // First corner\\n    vec2 i  = floor(v + dot(v, C.yy) );\\n    vec2 x0 = v -   i + dot(i, C.xx);\\n\\n    // Other corners\\n    vec2 i1;\\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\\n    //i1.y = 1.0 - i1.x;\\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\\n    // x1 = x0 - i1 + 1.0 * C.xx ;\\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\\n    vec4 x12 = x0.xyxy + C.xxzz;\\n    x12.xy -= i1;\\n\\n    // Permutations\\n    i = mod289(i); // Avoid truncation effects in permutation\\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\\n        + i.x + vec3(0.0, i1.x, 1.0 ));\\n\\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\\n    m = m*m ;\\n    m = m*m ;\\n\\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\\n\\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\\n    vec3 h = abs(x) - 0.5;\\n    vec3 ox = floor(x + 0.5);\\n    vec3 a0 = x - ox;\\n\\n    // Normalise gradients implicitly by scaling m\\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\\n\\n    // Compute final noise value at P\\n    vec3 g;\\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\\n    return 130.0 * dot(m, g);\\n}\\n\\nvec3 curl(float\\tx,\\tfloat\\ty,\\tfloat\\tz)\\n{\\n\\n    float\\teps\\t= 1., eps2 = 2. * eps;\\n    float\\tn1,\\tn2,\\ta,\\tb;\\n\\n    x += time * .05;\\n    y += time * .05; \\n    z += time * .05;\\n\\n    vec3\\tcurl = vec3(0.);\\n\\n    n1\\t=\\tnoise(vec2( x,\\ty\\t+\\teps ));\\n    n2\\t=\\tnoise(vec2( x,\\ty\\t-\\teps ));\\n    a\\t=\\t(n1\\t-\\tn2)/eps2;\\n\\n    n1\\t=\\tnoise(vec2( x,\\tz\\t+\\teps));\\n    n2\\t=\\tnoise(vec2( x,\\tz\\t-\\teps));\\n    b\\t=\\t(n1\\t-\\tn2)/eps2;\\n\\n    curl.x\\t=\\ta\\t-\\tb;\\n\\n    n1\\t=\\tnoise(vec2( y,\\tz\\t+\\teps));\\n    n2\\t=\\tnoise(vec2( y,\\tz\\t-\\teps));\\n    a\\t=\\t(n1\\t-\\tn2)/eps2;\\n\\n    n1\\t=\\tnoise(vec2( x\\t+\\teps,\\tz));\\n    n2\\t=\\tnoise(vec2( x\\t+\\teps,\\tz));\\n    b\\t=\\t(n1\\t-\\tn2)/eps2;\\n\\n    curl.y\\t=\\ta\\t-\\tb;\\n\\n    n1\\t=\\tnoise(vec2( x\\t+\\teps,\\ty));\\n    n2\\t=\\tnoise(vec2( x\\t-\\teps,\\ty));\\n    a\\t=\\t(n1\\t-\\tn2)/eps2;\\n\\n    n1\\t=\\tnoise(vec2(  y\\t+\\teps,\\tz));\\n    n2\\t=\\tnoise(vec2(  y\\t-\\teps,\\tz));\\n    b\\t=\\t(n1\\t-\\tn2)/eps2;\\n\\n    curl.z\\t=\\ta\\t-\\tb;\\n\\n    return\\tcurl;\\n}\\n\\nvoid main() {\\n\\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\\n    vec4 tmpPos = texture2D(texturePosition, uv);\\n    vec3 pos = tmpPos.xyz;\\n    float f = 1.;\\n    float amplitude = 0.0001;\\n    vec3 target = pos + amplitude * curl(f*pos.x, f*pos.y, f*pos.z); \\n\\n    gl_FragColor = vec4(target, 1.);\\n\\n}\\n\";"},"lineCount":null}},"error":null,"hash":"23c0bcb7a25d77851eca959ca2f2fa35","cacheData":{"env":{}}}