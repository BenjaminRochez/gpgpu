{"id":"js/shader/vertexParticles.glsl","dependencies":[{"name":"/Users/benjamin/htdocs/face/package.json","includedInParent":true,"mtime":1628488138071}],"generated":{"js":"module.exports = \"#define GLSLIFY 1\\nuniform float time;\\nvarying vec2 vUv;\\nvarying vec3 vPosition;\\nuniform sampler2D texture1;\\nuniform sampler2D positionTexture;\\nattribute vec2 references;\\nfloat PI = 3.141592653589793238;\\n\\n//\\n// Description : Array and textureless GLSL 2D simplex noise function.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : ijm\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//\\n\\nvec3 mod289(vec3 x) {\\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec2 mod289(vec2 x) {\\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec3 permute(vec3 x) {\\n    return mod289(((x*34.0)+1.0)*x);\\n}\\n\\nfloat noise(vec2 v)\\n{\\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\\n                      0.024390243902439); // 1.0 / 41.0\\n    // First corner\\n    vec2 i  = floor(v + dot(v, C.yy) );\\n    vec2 x0 = v -   i + dot(i, C.xx);\\n\\n    // Other corners\\n    vec2 i1;\\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\\n    //i1.y = 1.0 - i1.x;\\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\\n    // x1 = x0 - i1 + 1.0 * C.xx ;\\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\\n    vec4 x12 = x0.xyxy + C.xxzz;\\n    x12.xy -= i1;\\n\\n    // Permutations\\n    i = mod289(i); // Avoid truncation effects in permutation\\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\\n        + i.x + vec3(0.0, i1.x, 1.0 ));\\n\\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\\n    m = m*m ;\\n    m = m*m ;\\n\\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\\n\\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\\n    vec3 h = abs(x) - 0.5;\\n    vec3 ox = floor(x + 0.5);\\n    vec3 a0 = x - ox;\\n\\n    // Normalise gradients implicitly by scaling m\\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\\n\\n    // Compute final noise value at P\\n    vec3 g;\\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\\n    return 130.0 * dot(m, g);\\n}\\n\\nvec3 curl(float\\tx,\\tfloat\\ty,\\tfloat\\tz)\\n{\\n\\n    float\\teps\\t= 1., eps2 = 2. * eps;\\n    float\\tn1,\\tn2,\\ta,\\tb;\\n\\n    x += time * .05;\\n    y += time * .05; \\n    z += time * .05;\\n\\n    vec3\\tcurl = vec3(0.);\\n\\n    n1\\t=\\tnoise(vec2( x,\\ty\\t+\\teps ));\\n    n2\\t=\\tnoise(vec2( x,\\ty\\t-\\teps ));\\n    a\\t=\\t(n1\\t-\\tn2)/eps2;\\n\\n    n1\\t=\\tnoise(vec2( x,\\tz\\t+\\teps));\\n    n2\\t=\\tnoise(vec2( x,\\tz\\t-\\teps));\\n    b\\t=\\t(n1\\t-\\tn2)/eps2;\\n\\n    curl.x\\t=\\ta\\t-\\tb;\\n\\n    n1\\t=\\tnoise(vec2( y,\\tz\\t+\\teps));\\n    n2\\t=\\tnoise(vec2( y,\\tz\\t-\\teps));\\n    a\\t=\\t(n1\\t-\\tn2)/eps2;\\n\\n    n1\\t=\\tnoise(vec2( x\\t+\\teps,\\tz));\\n    n2\\t=\\tnoise(vec2( x\\t+\\teps,\\tz));\\n    b\\t=\\t(n1\\t-\\tn2)/eps2;\\n\\n    curl.y\\t=\\ta\\t-\\tb;\\n\\n    n1\\t=\\tnoise(vec2( x\\t+\\teps,\\ty));\\n    n2\\t=\\tnoise(vec2( x\\t-\\teps,\\ty));\\n    a\\t=\\t(n1\\t-\\tn2)/eps2;\\n\\n    n1\\t=\\tnoise(vec2(  y\\t+\\teps,\\tz));\\n    n2\\t=\\tnoise(vec2(  y\\t-\\teps,\\tz));\\n    b\\t=\\t(n1\\t-\\tn2)/eps2;\\n\\n    curl.z\\t=\\ta\\t-\\tb;\\n\\n    return\\tcurl;\\n}\\n\\nvoid main() {\\n  vUv = references;\\n\\n  vec3 pos = texture(positionTexture, references).xyz;\\n  vec3 newpos = position;\\n  float f = 5.;\\n  float amplitude = 1.;\\n  float maxDistance = 2.;\\n  \\n  vec3 target = position+curl( newpos.x * f, newpos.y * f, newpos.z * f ) * amplitude;\\n  \\n  float d = length( newpos-target ) / maxDistance;\\n  newpos = mix( position, target, pow( d, 5. ) );\\n\\n  vec4 mvPosition = modelViewMatrix * vec4( newpos, 1. );\\n  gl_PointSize = 1.5 * ( 1. / - mvPosition.z );\\n  gl_Position = projectionMatrix * mvPosition;\\n}\";"},"sourceMaps":{"js":{"mappings":[{"name":"module","generated":{"line":1,"column":0},"source":"js/shader/vertexParticles.glsl","original":{"line":1,"column":0}},{"generated":{"line":1,"column":6},"source":"js/shader/vertexParticles.glsl","original":{"line":1,"column":6}},{"name":"exports","generated":{"line":1,"column":7},"source":"js/shader/vertexParticles.glsl","original":{"line":1,"column":7}},{"generated":{"line":1,"column":14},"source":"js/shader/vertexParticles.glsl","original":{"line":1,"column":0}},{"generated":{"line":1,"column":17},"source":"js/shader/vertexParticles.glsl","original":{"line":1,"column":15}},{"generated":{"line":1,"column":4054},"source":"js/shader/vertexParticles.glsl","original":{"line":1,"column":0}}],"sources":{"js/shader/vertexParticles.glsl":"module.exports=\"#define GLSLIFY 1\\nuniform float time;\\nvarying vec2 vUv;\\nvarying vec3 vPosition;\\nuniform sampler2D texture1;\\nuniform sampler2D positionTexture;\\nattribute vec2 references;\\nfloat PI = 3.141592653589793238;\\n\\n//\\n// Description : Array and textureless GLSL 2D simplex noise function.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : ijm\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//\\n\\nvec3 mod289(vec3 x) {\\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec2 mod289(vec2 x) {\\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec3 permute(vec3 x) {\\n    return mod289(((x*34.0)+1.0)*x);\\n}\\n\\nfloat noise(vec2 v)\\n{\\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\\n                      0.024390243902439); // 1.0 / 41.0\\n    // First corner\\n    vec2 i  = floor(v + dot(v, C.yy) );\\n    vec2 x0 = v -   i + dot(i, C.xx);\\n\\n    // Other corners\\n    vec2 i1;\\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\\n    //i1.y = 1.0 - i1.x;\\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\\n    // x1 = x0 - i1 + 1.0 * C.xx ;\\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\\n    vec4 x12 = x0.xyxy + C.xxzz;\\n    x12.xy -= i1;\\n\\n    // Permutations\\n    i = mod289(i); // Avoid truncation effects in permutation\\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\\n        + i.x + vec3(0.0, i1.x, 1.0 ));\\n\\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\\n    m = m*m ;\\n    m = m*m ;\\n\\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\\n\\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\\n    vec3 h = abs(x) - 0.5;\\n    vec3 ox = floor(x + 0.5);\\n    vec3 a0 = x - ox;\\n\\n    // Normalise gradients implicitly by scaling m\\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\\n\\n    // Compute final noise value at P\\n    vec3 g;\\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\\n    return 130.0 * dot(m, g);\\n}\\n\\nvec3 curl(float\\tx,\\tfloat\\ty,\\tfloat\\tz)\\n{\\n\\n    float\\teps\\t= 1., eps2 = 2. * eps;\\n    float\\tn1,\\tn2,\\ta,\\tb;\\n\\n    x += time * .05;\\n    y += time * .05; \\n    z += time * .05;\\n\\n    vec3\\tcurl = vec3(0.);\\n\\n    n1\\t=\\tnoise(vec2( x,\\ty\\t+\\teps ));\\n    n2\\t=\\tnoise(vec2( x,\\ty\\t-\\teps ));\\n    a\\t=\\t(n1\\t-\\tn2)/eps2;\\n\\n    n1\\t=\\tnoise(vec2( x,\\tz\\t+\\teps));\\n    n2\\t=\\tnoise(vec2( x,\\tz\\t-\\teps));\\n    b\\t=\\t(n1\\t-\\tn2)/eps2;\\n\\n    curl.x\\t=\\ta\\t-\\tb;\\n\\n    n1\\t=\\tnoise(vec2( y,\\tz\\t+\\teps));\\n    n2\\t=\\tnoise(vec2( y,\\tz\\t-\\teps));\\n    a\\t=\\t(n1\\t-\\tn2)/eps2;\\n\\n    n1\\t=\\tnoise(vec2( x\\t+\\teps,\\tz));\\n    n2\\t=\\tnoise(vec2( x\\t+\\teps,\\tz));\\n    b\\t=\\t(n1\\t-\\tn2)/eps2;\\n\\n    curl.y\\t=\\ta\\t-\\tb;\\n\\n    n1\\t=\\tnoise(vec2( x\\t+\\teps,\\ty));\\n    n2\\t=\\tnoise(vec2( x\\t-\\teps,\\ty));\\n    a\\t=\\t(n1\\t-\\tn2)/eps2;\\n\\n    n1\\t=\\tnoise(vec2(  y\\t+\\teps,\\tz));\\n    n2\\t=\\tnoise(vec2(  y\\t-\\teps,\\tz));\\n    b\\t=\\t(n1\\t-\\tn2)/eps2;\\n\\n    curl.z\\t=\\ta\\t-\\tb;\\n\\n    return\\tcurl;\\n}\\n\\nvoid main() {\\n  vUv = references;\\n\\n  vec3 pos = texture(positionTexture, references).xyz;\\n  vec3 newpos = position;\\n  float f = 5.;\\n  float amplitude = 1.;\\n  float maxDistance = 2.;\\n  \\n  vec3 target = position+curl( newpos.x * f, newpos.y * f, newpos.z * f ) * amplitude;\\n  \\n  float d = length( newpos-target ) / maxDistance;\\n  newpos = mix( position, target, pow( d, 5. ) );\\n\\n  vec4 mvPosition = modelViewMatrix * vec4( newpos, 1. );\\n  gl_PointSize = 1.5 * ( 1. / - mvPosition.z );\\n  gl_Position = projectionMatrix * mvPosition;\\n}\";"},"lineCount":null}},"error":null,"hash":"72c5a20952fa246c038dc5559de86020","cacheData":{"env":{}}}